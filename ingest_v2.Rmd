---
title: "ingest"
output: html_document
---

```{r setup, message=FALSE, warning=FALSE}
library(data.table)

options(scipen = 999)  # disable scientific notation

# Function to load CSVs and normalize column names
load_csv <- function(path) {
  dt <- fread(path)
  setnames(dt, toupper(names(dt)))
  return(dt)
}

drg_info <- load_csv("data/DRG_INFO.csv")        
drg_procedure <- load_csv("data/DRG_PROCEDURE.csv")     
drg_diagnosis <- load_csv("data/DRG_DIAGNOSIS.csv")     
drg_warning_error <- load_csv("data/DRG_WARNING_ERROR.csv") 
drg_audittrail <- load_csv("data/DRG_TRAIL.csv")    
drg_result <- load_csv("data/DRG_RESULT.csv")
cf2_hcp <- load_csv("data/CLAIMS HCP.csv")    
cf2_Q1_to_Q2 <- load_csv("data/CLAIMS JAN TO JULY 2025.csv")
```

```{r}
str(drg_info)
str(drg_procedure)
str(drg_diagnosis)
str(drg_warning_error)
str(drg_audittrail)
str(drg_result)
str(cf2_hcp)
str(cf2_Q1_to_Q2)
str(master_flat)
```

# ---------------- Join all tables using SERIES / LHIO / CLAIMNUMBER ----------------

```{r}
# Join step by step
master <- merge(
  drg_info, drg_procedure,
  by.x = c("SERIES","LHIO","CLAIMNUMBER"), 
  by.y = c("SERIES","LHIO","CLAIM_ID"),
  all.x = TRUE, suffixes = c("", "_PROC")
)

master <- merge(
  master, drg_diagnosis,
  by.x = c("SERIES","LHIO","CLAIMNUMBER"), 
  by.y = c("SERIES","LHIO","CLAIM_ID"),
  all.x = TRUE, suffixes = c("", "_DIAG")
)

master <- merge(
  master, drg_warning_error,
  by.x = c("SERIES","LHIO","CLAIMNUMBER"), 
  by.y = c("SERIES","LHIO","CLAIM_ID"),
  all.x = TRUE, suffixes = c("", "_WARN")
)

# DRG_TRAIL (audit trail) has no LHIO; merge on SERIES + CLAIMNUMBER only
master <- merge(
  master, drg_audittrail,
  by = c("SERIES","CLAIMNUMBER"),
  all.x = TRUE, suffixes = c("", "_AUDIT")
)

# DRG_RESULT uses CLAIMS_SERIES and CLAIM_ID; map to SERIES and CLAIMNUMBER
master <- merge(
  master, drg_result,
  by.x = c("SERIES","LHIO","CLAIMNUMBER"),
  by.y = c("CLAIMS_SERIES","LHIO","CLAIM_ID"),
  all.x = TRUE, suffixes = c("", "_RESULT")
)

# Convert ID-like columns to character
id_cols <- grep("ID$|CLAIMNUMBER$|SERIES|LHIO", names(master), value = TRUE)
master[, (id_cols) := lapply(.SD, as.character), .SDcols = id_cols]

# Create human-readable composite key
master[, COMPOSITE_KEY := paste(SERIES, LHIO, CLAIMNUMBER, sep = "_")]

cat("Initial long table → Rows:", nrow(master), " Cols:", ncol(master), "\n")
```

# ---------------- Collapse duplicates into one row per composite key ----------------

```{r}
# Collapse duplicates per composite key
collapse_fun <- function(x) {
  vals <- unique(na.omit(x))
  paste(vals, collapse = "||")
}

master_flat <- master[, lapply(.SD, collapse_fun), by = COMPOSITE_KEY]

cat("Collapsed final table → Rows:", nrow(master_flat), " Cols:", ncol(master_flat), "\n")
head(master_flat)
```

# ---------------- Export Master Table ----------------

```{r}
fwrite(master_flat, "data/master_table_flat.csv")
cat("Master table saved to: data/master_table_flat.csv\n")
fwrite(master, "data/master_table.csv")
cat("Master table saved to: data/master_table.csv\n")
```

```{r}
library(data.table)

detect_type <- function(value) {
  # Patterns
  is_numeric <- grepl("^[0-9.]+$", value)
  is_alpha <- grepl("^[A-Za-z]+$", value)
  is_alnum <- grepl("^[A-Za-z0-9.]+$", value)
  is_date <- grepl("^\\d{2}/\\d{2}/\\d{4}(\\s+\\d{2}\\.\\d{2}\\.\\d{2}\\.\\d+\\s*(AM|PM)?)?$", 
                   value, ignore.case = TRUE)
  
  if (is_date) {
    return("DATE (any format)")
  } else if (is_numeric) {
    return("NUMERICAL (0-9. only)")
  } else if (is_alpha) {
    return("ALPHABETICAL (a-zA-Z only)")
  } else if (is_alnum) {
    return("ALPHANUMERICAL (a-zA-Z0-9.)")
  } else {
    return("STRING (also has char other than a-zA-Z0-9.)")
  }
}


for (i in seq_along(master)) {
  colname <- names(master)[i]
  values <- unique(master[[i]])
  values <- as.character(values)
  values <- values[!is.na(values)]  # keep empty string if exists
  
  cat("COL", i, ": ", colname, "\n", sep = "")
  
  if (length(unique(values)) < 10) {
    # Print all unique values if less than 10
    cat(values, sep = "\n")
  } else {
    # Otherwise, one representative per type
    types <- sapply(values[values != ""], detect_type)
    reps <- tapply(values[values != ""], types, `[`, 1)
    cat(reps, sep = "\n")
  }
  
  # Determine all types present
  types_all <- sapply(values[values != ""], detect_type)
  types_unique <- unique(types_all)
  
  # Include EMPTY type if there are blank values
  if (any(values == "")) {
    types_unique <- c(types_unique, "EMPTY")
  }
  
  cat("\nFORMAT:\n")
  cat(types_unique, sep = "\n")
  cat("\n\n")
}
```

```{r}
library(data.table)

# Ensure all SERIES and LHIO are the same type
master_flat[, SERIES := as.character(SERIES)]
master_flat[, LHIO := as.character(LHIO)]

cf2_hcp[, SERIES := as.character(SERIES)]
cf2_hcp[, LHIO := as.character(LHIO)]

cf2_Q1_to_Q2[, SERIES := as.character(SERIES)]
cf2_Q1_to_Q2[, LHIO := as.character(LHIO)]

# Combine CF2 sources into one
cf2_all <- rbindlist(list(
  cf2_hcp[, .(SERIES, LHIO)],
  cf2_Q1_to_Q2[, .(SERIES, LHIO)]
), use.names = TRUE, fill = TRUE)

cf2_all <- unique(cf2_all)

# Inner join to find matches
matches <- merge(
  unique(master_flat[, .(SERIES, LHIO)]),
  cf2_all,
  by = c("SERIES", "LHIO"),
  all.x = FALSE,
  all.y = FALSE
)

# Output results
total_master <- uniqueN(master_flat[, .(SERIES, LHIO)])
total_cf2 <- uniqueN(cf2_all)
total_matches <- nrow(matches)

cat("Unique claims in CF5 (SB):", total_master, "\n")
cat("Unique claims in CF2 (combined):", total_cf2, "\n")
cat("Claims found in both:", total_matches, "\n")
cat("Percentage of SB claims found in CF2:",
    round(100 * total_matches / total_master, 2), "%\n")
```
